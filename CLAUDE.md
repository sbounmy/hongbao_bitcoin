# Hongbao Rails Development with ClaudeOnRails

This project uses ClaudeOnRails to create an intelligent swarm of AI agents specialized in different aspects of Rails development.

## Project Overview

- **Application**: Hongbao
- **Rails Version**: 8.0.2
- **Ruby Version**: 3.2.8
- **Type**: Full-stack Rails application
- **Test Framework**: RSpec

## How to Use

Simply describe what you want to build or fix, and the swarm will automatically coordinate the implementation:

```bash
# Start the swarm
claude-swarm orchestrate

# Then just describe your task
claude "Add user authentication with email confirmation"
claude "Optimize the dashboard queries that are running slowly"
claude "Create an API endpoint for mobile app integration"
```

## Swarm Architecture

The following specialized agents work together to implement your requests:

- **Architect**: Coordinates all development and makes high-level decisions
- **Models**: Handles ActiveRecord models, migrations, and database design
- **Controllers**: Manages request handling, routing, and controller logic
- **Views**: Creates and maintains views, View Components, layouts, and partials
- **Stimulus**: Implements interactive features with Stimulus controllers
- **Services**: Extracts business logic into service objects
- **Jobs**: Handles background processing and async tasks
- **Tests**: Ensures comprehensive test coverage with RSpec
- **DevOps**: Manages deployment and production configurations

## Project Conventions

### Code Style
- Follow Rails conventions and best practices
- Use RuboCop for Ruby style enforcement
- Prefer clarity over cleverness
- Write self-documenting code

### Testing
- RSpec for all tests except user interations.
- Fixtures for test data
- Request specs for API endpoints
- E2E playwright for user interactions

### E2E Testing Best Practices

When writing E2E tests with Playwright, use maintainable selectors that won't break easily with UI/UX changes:

**Good Selectors (Preferred):**
- Semantic roles: `page.getByRole('button', { name: 'Submit' })`
- Visible text: `page.getByText('Welcome to our site')`
- Labels: `page.getByLabel('Email Address')`
- Placeholders: `page.getByPlaceholder('Enter your email')`
- Test IDs (when necessary): `page.getByTestId('submit-form')`
- ARIA attributes: `page.getByRole('navigation')`, `page.getByRole('main')`

**Bad Selectors (Avoid):**
- CSS classes: `page.locator('.lg\\:col-span-4')` - Classes change with styling
- Generic elements: `page.locator('body')` - Too broad and brittle
- Complex CSS paths: `page.locator('div > span.text-sm')` - Tightly coupled to DOM structure
- nth-child selectors: `page.locator('li:nth-child(3)')` - Order may change

**Example:**
```javascript
// ❌ Bad - Uses CSS classes that may change
await page.locator('.lg\\:col-span-4').click();
await page.locator('body').fill('some text');

// ✅ Good - Uses semantic selectors
await page.getByRole('button', { name: 'Save Event' }).click();
await page.getByLabel('Event Name').fill('Bitcoin Pizza Day');
await page.getByText('Delete Event').click();
```

The goal is to write tests that read like user stories and survive refactoring of the implementation details.

### Git Workflow
- Feature branches for new work
- Descriptive commit messages
- PR reviews before merging
- Keep main branch deployable

## Custom Patterns

Add your project-specific patterns and conventions here:

```yaml
# Example: Custom service object pattern
Services:
  Pattern: Command pattern with Result objects
  Location: app/services/
  Naming: VerbNoun (e.g., CreateOrder, SendEmail)
  Testing: Unit tests with mocked dependencies
```

## Notes

- This configuration was generated by ClaudeOnRails
- Customize agent prompts in `.claude-on-rails/prompts/`
- Update this file with project-specific conventions
- The swarm learns from your codebase patterns